# Algorithms and Complexity 
---
> [!info]+ Module Details
> Contains details on this (genus:: Module) from [Year::2]: Module tag, Teacher tags and Resources 
> > *Module :*  [[Algorithms & Complexity]]
> > *Teacher*: Thomas Powell, Ali Uncu, Guy MCusker
> > *Resources :* [Intro to theory of Computation](http://debracollege.dspaces.org/bitstream/123456789/671/1/Introduction%20to%20the%20Theory%20of%20Computation_2013%20Sipser.pdf#:~:text=Introduction%20to%20the%20Theory%20of%20Computation,%20Third%20Edition)
> > 

---
> [!abstract]+ Contents
> List of links to notes on Topics within the Module
> Semester 1
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Finite Automata & Regular Languages]]
> [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Pumping Lemma]]
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/How to use the Pumping Lemma]]
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Pushdown Automata]]
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Turing Machine in Automata]]
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Church-Turing Thesis]]
> 
> Semester 2 
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Sem 2 Breakdown Alg&C]]
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Complexity]]
> > [[Yr2 NotesðŸ“˜/Semester 1 & 2/Algo & Complexity/Sorting]]
> > [[]]


---
### Coursework 25 vs 75 Examed
- Set exercises individual (CWSI 25%)
	**Details** - covers first part of Sem 1 
		Already finished
- Closed-book written examination (EXCB 75%)
	**Details** - Intended to test basic knowledge of the unit material, plus ability to solve routine problems. Problems will be roughly as difficult as the core weekly exercises
---
### Course Description

> [!info]+  Course Description
> 
|                        | Content        |
| ---------------------- | -------------- |
| **Learning Outcomes:** | 1. describe the fundamental models of computation and the corresponding classes of formal grammars and languages;<br>2. design algorithms for specific computational problems as automata of appropriate types;<br>3. prove mathematically that some computational problems are undecidable within a particular class of computational models;<br>4. determine the complexity of a variety of algorithms;<br>5. describe a variety of data structures and algorithms and choose appropriate ones for solving a given computational problem;<br>6. for a variety of algorithms, demonstrate their correctness in certain respects.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **Synopsis:**          | You will explore fundamental models of computation such as finite automata and Turing machines, design algorithms within a given model, and formally prove that a problem cannot be addressed within a given model. You will learn about a variety of data structures and choose an appropriate one for a given problem. You will determine the computational complexity of algorithms and demonstrate their correctness.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| **Content:**           | SEMSETER 1 <br> Regular languages; deterministic and non-deterministic finite automata; existence of non-regular languages via the Pumping Lemma. Context-free languages; pushdown automata; context-free grammars; parsing in context-free languages; existence of non-context-free languages via the Pumping Lemma. Turing machines; Church-Turing Thesis; Universal Turing machine and undecidability of the halting problem. Non-deterministic Turing machines; complexity classes $P$ and $NP$; $P$ vs $NP$ problem. <br> SEMESTER 2 <br> Data structures such as lists, stacks, queues, trees, hash tables, heaps, graphs, and self-balancing trees. Methods of designing efficient algorithms such as divide-and-conquer, recursion, dynamic programming, and greedy algorithms. Complexity; best, worst and average cases; time, space and other measures; $big ÎŸ$, $big \Theta$ and $big Î©$ notation. Analysis of algorithms such as sorting algorithms, graph algorithms, and algorithms for linear algebra. Basic correctness techniques including loop invariants. Algorithms and data structures in practice; crossover points between algorithms; polyalgorithms; computationally hard problems in everyday life. |

---

> [!sigma]+ Sem 1
> The symbol contains everything and defaults to note
![[Algo & Complexity Sem 1 Content.png| 500]]

> [!omega]+ Sem 2
> The symbol contains everything and defaults to note

---


