# AlgoSexy Key Terms
---
> [!info]+ File Details
> > *Date :*  26-04-2025  
> > *Module :* [[Yr2 NotesğŸ“˜/Semester 1 & 2/Algo & Complexity/Algorithms and Complexity]]  
> > *Teacher*: #Chatted  
> > *Resources :*  

---
> [!abstract]+ Contents
> > [[#âš¡ Speed run]]
> > [[#ğŸ§® Definitions by Topic]]

---
> [!danger]+ âš¡ *Speed run*
> - **Automata & Formal Languages**: DFA, NFA, PFA, Pumping Lemma (regular), CFL, CFG, PDA, Pumping Lemma (context-free), Parsing  
> - **Turing Machines & Computability**: Turing Machine, Universal TM, Church-Turing Thesis, Halting Problem, Decidability, Undecidability  
> - **Complexity Classes**: P, NP, NP-Complete, P vs NP, Non-deterministic TM  
> - **Data Structures**: Array, Linked List, Stack, Queue, Tree, BST, AVL, Heap, Graph, Hash Table, Disjoint Set (Union-Find)  
> - **Algorithm Design**: Divide-and-Conquer, Dynamic Programming, Greedy, Recursion, Memoization  
> - **Algorithm Analysis**: Best/Worst/Average Case, Time, Space, Big-O, Big-Î˜, Big-Î©, Loop Invariants  
> - **Sorting & Searching**: Selection Sort, Insertion Sort, Merge Sort, Quicksort, HeapSort, TreeSort, BFS, DFS, Dijkstra, Floyd-Warshall, Kruskal  
> - **Special Topics**: Ackermann Function, Inverse Ackermann, Polyalgorithms, Cache Efficiency, Crossover Points

---
## ğŸ§® Definitions by Topic

> [!note]+ Automata & Formal Languages
> - **DFA (Deterministic Finite Automaton)**: Machine with exactly one transition for each input from a given state. Recognizes regular languages.
> - **NFA (Non-deterministic Finite Automaton)**: Allows multiple possible transitions for a given input. Still recognizes regular languages.
> - **PFA (Probabilistic Finite Automaton)**: Stochastic model with probabilistic transitions between states.
> - **Pumping Lemma (Regular)**: Property used to prove that certain languages are not regular.
> - **CFL (Context-Free Language)**: Languages generated by a context-free grammar (CFG).
> - **CFG (Context-Free Grammar)**: Set of recursive rewriting rules to generate patterns of strings.
> - **PDA (Pushdown Automaton)**: Like NFA but with a stack; recognizes context-free languages.
> - **Pumping Lemma (CFL)**: Property to prove certain languages are not context-free.
> - **Parsing**: Process of analyzing a string according to grammar rules.

> [!info]+ Turing Machines & Computability
> - **Turing Machine**: An abstract model with infinite tape and a read/write head capable of simulating any computation.
> - **Formal TM Definition**: A 7-tuple $(Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$ where:
>     - $Q$: Set of states
>     - $\Sigma$: Input alphabet
>     - $\Gamma$: Tape alphabet
>     - $\delta$: Transition function
>     - $q_0$: Start state
>     - $q_{accept}$: Accepting state
>     - $q_{reject}$: Rejecting state
> - **Universal Turing Machine**: A TM that simulates other TMs.
> - **Church-Turing Thesis**: Anything computable can be computed by a TM.
> - **Halting Problem**: No general algorithm can decide whether an arbitrary TM halts.
> - **Decidability**: Problem is solvable by a TM that always halts.
> - **Undecidability**: No TM can decide it for all inputs.

> [!tip]+ Complexity Classes
> - **P**: Problems solvable in polynomial time.
> - **NP**: Problems verifiable in polynomial time.
> - **NP-Complete**: Hardest problems in NP; all NP problems reduce to them.
> - **P vs NP**: Major open problem asking if every problem whose solution can be verified quickly can also be solved quickly.
> - **Non-deterministic Turing Machine**: TM that can explore many possibilities simultaneously.

> [!success]+ Data Structures
> - **Array**: Fixed-size sequential storage.
> - **Linked List**: Elements linked via pointers.
> - **Stack**: Last-In-First-Out (LIFO) structure.
> - **Queue**: First-In-First-Out (FIFO) structure.
> - **Tree**: Hierarchical structure.
> - **Binary Search Tree (BST)**: Ordered binary tree.
> - **AVL Tree**: Self-balancing binary tree.
> - **Heap**: Binary tree satisfying heap property (min/max at root).
> - **Graph**: Collection of vertices and edges.
> - **Hash Table**: Fast key-value storage.
> - **Disjoint Set (Union-Find)**: Structure for partitioning elements into disjoint sets.
> - **Path Compression**: Technique in Union-Find to flatten trees and speed up find operations.
> - **Union by Rank**: Balances trees during union operations.

> [!abstract]+ Algorithm Design
> - **Divide-and-Conquer**: Recursively break down problems into subproblems.
> - **Dynamic Programming**: Solves overlapping subproblems by storing solutions.
> - **Greedy**: Always chooses the best local option hoping for global optimum.
> - **Recursion**: Function calling itself.
> - **Memoization**: Storing results of expensive function calls.

> [!warning]+ Algorithm Analysis
> - **Best Case**: Minimum effort needed.
> - **Worst Case**: Maximum effort needed.
> - **Average Case**: Expected effort over all inputs.
> - **Time Complexity**: Runtime relative to input size.
> - **Space Complexity**: Memory usage relative to input size.
> - **Big-O**: Upper bound.
> - **Big-Î˜**: Tight bound.
> - **Big-Î©**: Lower bound.
> - **Loop Invariant**: Property holding before and after each loop iteration.

> [!omega]+ Sorting & Searching
> - **Selection Sort**: Find min repeatedly â€” $\Theta(n^2)$.
> - **Insertion Sort**: Insert into sorted portion â€” $\Theta(n^2)$.
> - **Merge Sort**: Recursive split and merge â€” $O(n \log n)$.
> - **Quicksort**: Partition around pivot â€” Avg: $O(n \log n)$, Worst: $O(n^2)$.
> - **HeapSort**: Heap-based sorting â€” $O(n \log n)$.
> - Create max heap, rem largest item, place in sorted, heapify repeat
> - **TreeSort**: BST-based sort.
> - **BFS/DFS**: Graph traversal.
> - **Dijkstra**: Single-source shortest paths with non-negative weights.
> - **Floyd-Warshall**: All-pairs shortest paths.
> - **Kruskalâ€™s Algorithm**: MST algorithm selecting smallest edges first.  
>     - Complexity: $O(E \log E)$
>     - Uses Disjoint Sets (Union-Find).

> [!heart]+ Special Topics
> - **Ackermann Function**: Rapidly growing recursive function. 
> - **Inverse Ackermann Function $\alpha(n)$**: Very slow-growing function, commonly appearing in amortized analyses.
> - **Polyalgorithm**: Combines multiple algorithms based on context.
> - **Cache Efficiency**: Optimization to make memory accesses faster.
> - **Algorithm Crossover Points**: Switching to faster algorithm depending on input size.
> - **Kruskal Algorithm** : Creates a minimum spanning tree. This appends cheapest unlinked edge

