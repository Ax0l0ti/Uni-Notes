# AlgoSexy Key Terms
---
> [!info]+ File Details
> Includes information about this (genus:: Note) from [Year::2]. Contains details on when this was created, what module the note belongs to.
> > *Date :*  14-04-2025  
> > *Module :* [[Algorithms and Complexity]]  
> > *Teacher*: #Chatted  
> > *Resources :*  

---
> [!abstract]+ Contents
> List of headings within this topic
> > [[#âš¡ Speed run]]
> > [[#ðŸ§® Definitions by Topic]]
> > [[#]]
> > [[#]]

---
> [!danger]+ âš¡ *Speed run*
> - **Automata & Formal Languages**: DFA, NFA, Pumping Lemma (regular), CFL, CFG, PDA, Pumping Lemma (context-free), Parsing  
> - **Turing Machines & Computability**: Turing Machine, Universal TM, Church-Turing Thesis, Halting Problem, Undecidability, Decidability  
> - **Complexity Classes**: P, NP, NP-Complete, P vs NP, Deterministic vs Non-deterministic TM  
> - **Data Structures**: Array, Linked List, Stack, Queue, Tree, BST, AVL, Heap, Graph, Hash Table  
> - **Algorithm Design**: Divide-and-Conquer, Dynamic Programming, Greedy, Recursion, Memoization  
> - **Algorithm Analysis**: Best/Worst/Average Case, Time & Space Complexity, Big-O, Big-Î©, Big-Î˜, Loop Invariants  
> - **Sorting & Searching**: Selection Sort, Insertion Sort, Merge Sort, QuickSort, HeapSort, Tree Sort, BFS, DFS, Dijkstra, Floyd-Warshall  
> - **Advanced Concepts**: Polyalgorithms, Cache Efficiency, Algorithm Crossover Points, Real-world Complexity

---
## ðŸ§® Definitions by Topic

> [!abstract]+ Automata & Formal Languages
> - **DFA**: Deterministic finite automaton â€” accepts regular languages with one transition per input symbol.
> - **NFA**: Non-deterministic finite automaton â€” allows multiple transitions for the same input.
> - **Pumping Lemma (Regular)**: Proof tool for showing a language is not regular.
> - **CFL (Context-Free Language)**: Generated by a context-free grammar.
> - **CFG**: Grammar where each production rule has a single non-terminal on the left.
> - **PDA**: Pushdown automaton â€” recognizes context-free languages using a stack.
> - **Pumping Lemma (CFL)**: Tool to prove a language is not context-free.
> - **Parsing**: Process of analyzing strings per grammar rules.

> [!info]+ Turing Machines & Computability
> - **Turing Machine**: Abstract computational model using tape and states.
> - **Universal Turing Machine**: Simulates any other Turing machine.
> - **Church-Turing Thesis**: Any effectively computable function can be computed by a TM.
> - **Halting Problem**: Undecidable problem of determining whether a TM halts.
> - **Undecidability**: No algorithm can solve the problem for all inputs.
> - **Decidability**: Problem solvable by a TM that halts on all inputs.

> [!tip]+ Complexity Classes
> - **P**: Problems solvable in polynomial time.
> - **NP**: Problems verifiable in polynomial time.
> - **NP-Complete**: Problems in NP as hard as any in NP.
> - **P vs NP**: Open question whether P = NP.
> - **Non-deterministic TM**: TM that can explore many paths in parallel.

> [!bug]+ Data Structures
> - **Array**: Fixed-size, indexed collection.
> - **Linked List**: Sequential data structure with node pointers.
> - **Stack**: LIFO structure with push/pop.
> - **Queue**: FIFO structure.
> - **Tree**: Hierarchical structure with parent/child nodes.
> - **BST**: Binary tree with left < root < right.
> - **AVL Tree**: Self-balancing BST.
> - **Heap**: Binary tree with max/min-heap property.
> - **Graph**: Set of nodes connected by edges.
> - **Hash Table**: Key-value store using hashing.

> [!success]+ Algorithm Design
> - **Divide-and-Conquer**: Split into subproblems, solve, merge.
> - **Dynamic Programming**: Store and reuse subproblem solutions.
> - **Greedy Algorithm**: Make the locally optimal choice at each step.
> - **Recursion**: Function calling itself on subproblems.
> - **Memoization**: Cache intermediate results to avoid recomputation.

> [!note]+ Algorithm Analysis
> - **Best Case**: Minimum time required.
> - **Worst Case**: Maximum time for any input.
> - **Average Case**: Expected time over all inputs.
> - **Time Complexity**: How runtime scales with input.
> - **Space Complexity**: Memory usage with input size.
> - **Big-O**: Upper bound.
> - **Big-Î©**: Lower bound.
> - **Big-Î˜**: Tight bound.
> - **Loop Invariant**: True before and after each loop iteration.

> [!warning]+ Sorting & Searching
> - **Selection Sort**: $\Theta(n^2)$ â€” repeatedly find min and place at front.
> - **Insertion Sort**: $\Theta(n^2)$ â€” insert elements into correct place.
> - **Merge Sort**: $O(n \log n)$ â€” split, sort, merge.
> - **Quicksort**: Average: $O(n \log n)$, Worst: $O(n^2)$.
> - **HeapSort**: $O(n \log n)$ using heap structure.
> - **Tree Sort**: BST-based sort; efficient with balanced tree.
> - **BFS/DFS**: Graph traversal techniques.
> - **Dijkstra**: Shortest path with positive weights.
> - **Floyd-Warshall**: All-pairs shortest paths.

> [!omega]+ Advanced Concepts
> - **Polyalgorithm**: Combines multiple algorithms for efficiency.
> - **Cache Efficiency**: Optimizing memory locality in algorithms.
> - **Algorithm Crossover**: Point where algorithm switch is beneficial.
> - **Real-World Complexity**: Computationally hard problems in practical domains.
